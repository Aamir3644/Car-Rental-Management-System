## What is OOPS ?
>> Object-Oriented Programming (OOP) is a fundamental approach in software development that centers around the idea of "objects". 
It provides a structured and organized approach to designing and building software systems. OOP is based on several key principles and features:

1) Classes and Objects :
>  A class is a user-defined blueprint from which objects are created. It represents the set of properties or methods that are common to all objects of one type. Using classes, you can create multiple objects with the same behavior instead of writing their code multiple times. An object is an instance of a class and represents a real-world entity.

2) Abstraction :
>  Data Abstraction is the property by which only the essential details are displayed to the user. The non-essential units are not displayed to the user. Ex: A car is viewed as a car rather than its individual components.
Consider a real-life example of a man driving a car. The man only knows that pressing the accelerators will increase the car speed or applying brakes will stop the car, but he does not know how on pressing the accelerator, the speed is actually increasing. He does not know about the inner mechanism of the car or the implementation of the accelerators, brakes etc. in the car. This is what abstraction is.

3) Encapsulation :
> Encapsulation is one of the four fundamental principles of object-oriented programming (OOP), and it refers to the concept of bundling data (attributes) and methods (functions) that operate on that data into a single unit called a class. Additionally, it restricts direct access to some of an object's components and prevents the accidental modification of data.
  Encapsulation allows you to hide the internal state (data or attributes) of an object from the outside world.
  In Java, encapsulation is implemented using access modifiers.
  To provide controlled access to the internal state of an object, getter and setter methods are commonly used.

4) Inheritance :
>  Inheritance is a mechanism in which one class acquires the property of another class.
   Inheritance is a fundamental object-oriented programming concept where a new class (the subclass) can inherit properties and behaviors (fields and methods) from an existing class (the superclass). It enables code reuse, promotes the "IS-A" relationship, and allows you to create a hierarchy of classes. Subclasses can extend or override inherited members, making it a powerful mechanism for organizing and structuring code.

5) Polymorphism :
>  It refers to the ability of object-oriented programming languages to differentiate between entities with the same name efficiently. The ability to appear in many forms is called polymorphism.

> Compile-Time Polymorphism (Static Binding):
  - Also known as method overloading.
  - Occurs during compile time.
  - Multiple methods in the same class have the same name but different parameter lists (number or types of parameters).
  - The correct method to call is determined at compile time based on the method signature.

> Run-Time Polymorphism (Dynamic Binding):

  - Also known as method overriding.
  - Occurs during runtime.
  - It allows a subclass to provide a specific implementation of a method that is already defined in its superclass.
  - The decision about which method to call is made at runtime based on the actual object type.




## Flow of Java Program :
>>
  A compiler is a program that translates the human-readable Java source code into a lower-level code called bytecode.       Bytecode is a platform-independent representation of the program. When you write Java code, you save it in a .java file. To run this code, you first need to compile it using a Java compiler (e.g., javac). The compiler checks the code for syntax errors and translates it into bytecode. The output of the compiler is a .class file containing the bytecode representation of your Java program. This .class file can be executed on any system with a compatible Java Virtual Machine (JVM), making Java platform-independent.
 
>> 
  The Java Virtual Machine (JVM) is responsible for interpreting and executing the bytecode generated by the compiler. It acts as an interpreter for the bytecode. When you run a Java program, you use the java command followed by the name of the class containing the main method. The JVM loads the bytecode from the .class file and executes it line by line.
  During execution, the JVM performs Just-In-Time (JIT) compilation, which means it may further compile some bytecode into native machine code to optimize performance. 


## What is the difference between C++ and Java ?
>> Compilation and Execution:

  C++: C++ is a statically typed language, which means the code is compiled directly into machine code before execution. It produces native binary executables.

  Java: Java is a statically typed language that compiles code into an intermediate bytecode, which is executed by the Java Virtual Machine (JVM). It is an interpreted language in this sense, which allows for platform independence.

>> Memory Management:

  C++: C++ provides manual memory management through features like pointers. Developers have fine-grained control over memory allocation and deallocation. This can lead to greater efficiency but also increases the risk of memory-related bugs like segmentation faults.

  Java: Java has automatic memory management through garbage collection. The JVM takes care of memory allocation and reclaims memory when objects are no longer referenced, reducing the risk of memory leaks.

>> Platform Independence:

  C++: Code written in C++ is platform-dependent. To run on different platforms, it needs to be recompiled for each target platform.

  Java: Java is platform-independent. Bytecode generated on one platform can run on any platform with a compatible JVM, making it highly portable.

>> Performance:

  C++: C++ is generally considered to have better performance due to its low-level features and direct hardware access. It is often chosen for high-performance applications, like game engines and real-time systems.

  Java: Java is known for its "write once, run anywhere" philosophy, but it can have slightly lower performance due to the JVM's overhead. However, modern JVMs have optimizations that make Java performance competitive for most applications.

>> Safety:

  C++: C++ offers more control but also more responsibility. Developers must manually handle memory management and can make low-level mistakes, potentially leading to crashes or security vulnerabilities.

  Java: Java provides safety features like automatic memory management and array bounds checking, reducing the risk of memory-related errors and buffer overflows.

## Which is better C++ and Java ?
>> Both C++ and Java are popular programming languages, but they have different strengths and weaknesses.
  C++ is generally considered to be faster and more efficient than Java because it allows for low-level memory manipulation.
  If you are working on performance-critical applications like game engines or embedded systems, C++ might be a better choice.

  Java is known for its "write once, run anywhere" philosophy. It is highly portable, as Java code is compiled to an intermediate bytecode that runs on the Java Virtual Machine (JVM). If cross-platform compatibility is a priority, Java may be the better option.

  So,there is no one-size-fits-all answer to whether C++ or Java is better. It depends on your specific needs, the nature of the project, and personal preferences.

## What is Method overloading and Method Overriding ? ( Why it is called Compile Time and Run Time Polymorphism ?)
>> Method overloading is called compile-time polymorphism because the decision about which overloaded method to call is made by the compiler during the compilation phase based on the method's signature (number and types of parameters). The compiler knows at compile time which method to bind to a specific method call, and it generates the appropriate code accordingly. Method overloading doesn't depend on the actual object type or the values of the arguments; it's purely based on the method's signature.

>> Method overriding, on the other hand, is called run-time polymorphism because the decision about which method to call is made at runtime based on the actual type of the object. When a subclass overrides a method from its superclass, the compiler doesn't decide which method to call when the code is compiled. Instead, the determination is deferred until the program is executed and an object's type is known at runtime. This allows for dynamic behavior where the correct method implementation is chosen based on the specific object being referenced.

## What is 'this' keyword ?
>> The this keyword in Java is a reference to the current instance of a class. It is used primarily within class methods and constructors to refer to the object on which the method is invoked or the object being constructed. This is particularly useful when there is a naming conflict between instance variables and method parameters or local variables.

## What is Constructor Chaining ?
>> constructor chaining is a sequence of invoking constructors upon initializing an object. It is used when we want to invoke a number of constructors, one after another by using only an instance.
> We can achieve constructor chaining in two ways:
- Within the same class: If the constructors belong to the same class, we use this
- From the base class: If the constructor belongs to different classes (parent and child classes), we use the super keyword to call the constructor from the base class.

## What is JDK , JRE , JVM ?
>> JDK : (Java Development Kit)
       JDK is a software package containing the tools, libraries, and executables needed for Java application development.
       JDK is used by developers for creating, compiling, and debugging Java applications.

>> JRE : (Java Runtime Environment)
       JRE is a package or software bundle that includes the JVM, core libraries, and necessary runtime components for executing Java applications.JRE provides the runtime environment for Java applications, enabling them to be executed on a specific platform.

>> JVM : (Java Virtual Machine)
       JVM is an integral part of the JRE responsible for executing Java bytecode. It takes compiled Java bytecode and translates it into native machine code, allowing Java applications to run on various platforms without modification.

## What is Wrapper Class ?
>> A wrapper class in Java is a class that wraps, or encapsulates, the primitive data types (such as int, char, float, etc.) into objects. Each primitive data type has a corresponding wrapper class in Java. The primary purpose of wrapper classes is to provide a way to treat primitive data types as objects.  It allows you to work with primitives as if they were objects, enabling features like using them in collections,generics and handling null values.

## What is Interface ?
>> An interface is a blueprint for a class that defines a set of abstract methods. Any class implementing the interface must provide concrete implementations for those methods.
Interface can not have method body. its methods are by default public and abstract.
Interfaces specify what a class must do and not how. It is the blueprint of the behaviour.
Interface do not have constructor. 
It is used to achieve abstraction.


## What is Reflection
>> Reflection in Java refers to the ability of a program to examine, introspect, and manipulate its own structure, classes, methods, fields, and objects at runtime. It provides a way to inspect and modify Java classes and objects dynamically, without knowing their names or details at compile time. Reflection is facilitated through the use of classes in the java.lang.reflect package.
The java.lang.Class class provides many methods that can be used to get metadata, examine and change the run time behavior of a class.


try(BufferedReader reader = new BufferedReader(new FileReader(sample.text))){
        String line;
        while(line = reader.readLine() != null)
        {
            System.out.println(line); 
        }
}catch(IOException e)
{
    e.printStackTrace();
}


try(BufferedWriter writer = new BufferedWriter(new FileWriter(output.txt))){
    writer.write("HELLO WORLD");
    writer.newLine();
    writer.write("Hi");
}catch(IOException e){
    e.printStackTrace();
}